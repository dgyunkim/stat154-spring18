x <- 1:9
matrix(x, nrow = 3, ncol = 3) # column-major
matrix(x, nrow = 3, ncol = 3, byrow = 1) # row-major
dig(5)
diag(5)
x <- 1:9
matrix(x, nrow = 3, ncol = 3) # column-major
matrix(x, nrow = 3, ncol = 3, byrow = 1) # row-major
diag(5)
a1 <- c(2, 3, 6, 7, 10)
a2 <- c(1.88, 2.05, 1.70, 1.60, 1.78)
a3 <- c(80, 90, 70, 50, 75)
A <- cbind(a1, a2, a3)
A
A <- cbind(a1, a2, a3)
rownames(A) <- 1:5
A
x <- 1:9
matrix(x, nrow = 3, ncol = 3) # column-major
matrix(x, nrow = 3, ncol = 3, byrow = 1) # row-major
diag(5)
a1 <- c(2, 3, 6, 7, 10)
a2 <- c(1.88, 2.05, 1.70, 1.60, 1.78)
a3 <- c(80, 90, 70, 50, 75)
A <- cbind(a1, a2, a3)
rownames(A) <- 1:5
A
b1 <- c(1, 4, 5, 8, 9)
b2 <- c(1.22, 1.05, 3.60, 0.40, 2.54)
b3 <- c(20, 40, 30, 80, 100)
x <- 1:9
matrix(x, nrow = 3, ncol = 3) # column-major
matrix(x, nrow = 3, ncol = 3, byrow = 1) # row-major
diag(5)
a1 <- c(2, 3, 6, 7, 10)
a2 <- c(1.88, 2.05, 1.70, 1.60, 1.78)
a3 <- c(80, 90, 70, 50, 75)
A <- cbind(a1, a2, a3)
rownames(A) <- 1:5
A
b1 <- c(1, 4, 5, 8, 9)
b2 <- c(1.22, 1.05, 3.60, 0.40, 2.54)
b3 <- c(20, 40, 30, 80, 100)
B <- rbind(b1, b2, b3)
B
B <- rbind(b1, b2, b3)
colnames(B) <- 1:5
B
A %*% B
B %*% A
t(A) %*% t(B)
t(B) %*% t(A)
iris
iris
library(dplyr) # load a package
dat <- select(iris, 1:4)
dat
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
v <- 1:4 # create numeric vector to compute a linear combination
v %*% dat
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
v <- 1:4 # create numeric vector to compute a linear combination
v %*% dat
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
v <- 1:4 # create numeric vector to compute a linear combination
v %*% mat
mat
t(mat) %*% v
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
v <- 1:4 # create numeric vector to compute a linear combination
t(mat) %*% v
class(mat)
A <- matrix(rep(1:4, nrow(mat)), nrow = nrow(mat), ncol = ncol(mat), byrow = 1)
A
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
A <- matrix(rep(1:4, nrow(mat)), nrow = nrow(mat), ncol = ncol(mat), byrow = 1)
B <- t(A) %*% mat
B
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
v <- 1:4 # create numeric vector to compute a linear combination
v
mat %*% v
mat
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
rownames(mat) <- 1:nrow(mat)
v <- 1:4 # create numeric vector to compute a linear combination
mat %*% v
colnames(A) <- "A"
colnames(A) <- c("A")
colnames(A)
colnames(A) <- "a"
class(A)
dimnames(A)
?colnames
names(A) <- "a"
A
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
rownames(mat) <- 1:nrow(mat)
v <- 1:4 # create numeric vector to compute a linear combination
A <- mat %*% v
names(A) <- "a"
A
rownames(A)
colnames(mat)
colnames(A)
colnames(A) <- colnames(mat)
ncol(A)
colnames(A) <- "asd"
A
attr(A)
attributes(A)
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
rownames(mat) <- 1:nrow(mat)
v <- 1:4 # create numeric vector to compute a linear combination
A <- mat %*% v
colnames(A) <- "asd"
A
library(stringr) # load a package
colnames(A) <- paste(v, colnames(mat), sep = " ")
paste(v, colnames(mat), sep = " ")
paste0(v, colnames(mat), sep = " ")
paste0(v, colnames(mat), sep = "*")
paste(v, colnames(mat), sep = "*")
x <- 1:9
matrix(x, nrow = 3, ncol = 3) # column-major
matrix(x, nrow = 3, ncol = 3, byrow = 1) # row-major
diag(5)
a1 <- c(2, 3, 6, 7, 10)
a2 <- c(1.88, 2.05, 1.70, 1.60, 1.78)
a3 <- c(80, 90, 70, 50, 75)
A <- cbind(a1, a2, a3)
rownames(A) <- 1:5
A
b1 <- c(1, 4, 5, 8, 9)
b2 <- c(1.22, 1.05, 3.60, 0.40, 2.54)
b3 <- c(20, 40, 30, 80, 100)
B <- rbind(b1, b2, b3)
colnames(B) <- 1:5
B
A %*% B
B %*% A
t(A) %*% t(B)
t(B) %*% t(A)
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
rownames(mat) <- 1:nrow(mat)
v <- 1:4 # create numeric vector to compute a linear combination
A <- mat %*% v
col_name <- paste(v, colnames(mat), sep = "*")
colnames(A) <- paste(col_name)
col_name
paste(col_name, sep = " + ")
paste("University", "of", "California", "Berkeley")
colnames(A) <- paste(col_name, collapse = " + ")
A
head(A)
head(mat)
5.1 + 3.5 + 1.4 + 0.2
5.1 + 7 + 4.2 + 0.8
head(A, n = 10)
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
rownames(mat) <- 1:nrow(mat)
v <- 1:4 # create numeric vector to compute a linear combination
A <- mat %*% v
col_name <- paste(v, colnames(mat), sep = "*")
colnames(A) <- paste(col_name, collapse = " + ")
head(A, n = 10)
head(mat, n = 10)
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
head(mat, n = 10)
rownames(mat) <- 1:nrow(mat)
v <- 1:4 # create numeric vector to compute a linear combination
A <- mat %*% v
col_name <- paste(v, colnames(mat), sep = "*")
colnames(A) <- paste(col_name, collapse = " + ")
head(A, n = 10)
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
rownames(mat) <- 1:nrow(mat)
head(mat, n = 10)
v <- 1:4 # create numeric vector to compute a linear combination
A <- mat %*% v
col_name <- paste(v, colnames(mat), sep = "*")
colnames(A) <- paste(col_name, collapse = " + ")
head(A, n = 10)
vnorm <- function(x) {
t(x) %*% x
}
v <- 1:5
vnorm(v)
vnorm <- function(x) {
mat <- t(x) %*% x
mat[1, 1]
}
vnorm <- function(x) {
mat <- t(x) %*% x
mat[1, 1]
}
v <- 1:5
vnorm(v)
vnorm <- function(x) {
as.vector(t(x) %*% x)
}
v <- 1:5
vnorm(v)
v
u <- v / vnorm(v)
u
vnorm(u)
v
u <- v / vnorm(v)
u
vnorm(u)
1/ 55
2 / 55
x <- 1:9
matrix(x, nrow = 3, ncol = 3) # column-major
matrix(x, nrow = 3, ncol = 3, byrow = 1) # row-major
diag(5)
a1 <- c(2, 3, 6, 7, 10)
a2 <- c(1.88, 2.05, 1.70, 1.60, 1.78)
a3 <- c(80, 90, 70, 50, 75)
A <- cbind(a1, a2, a3)
rownames(A) <- 1:5
A
b1 <- c(1, 4, 5, 8, 9)
b2 <- c(1.22, 1.05, 3.60, 0.40, 2.54)
b3 <- c(20, 40, 30, 80, 100)
B <- rbind(b1, b2, b3)
colnames(B) <- 1:5
B
A %*% B
B %*% A
t(A) %*% t(B)
t(B) %*% t(A)
library(dplyr) # load a package
dat <- select(iris, 1:4) # need first 4 columns of data frame "iris"
mat <- as.matrix(dat) # convert data frame into matrix
rownames(mat) <- 1:nrow(mat)
head(mat, n = 10)
v <- 1:4 # create numeric vector to compute a linear combination
A <- mat %*% v
col_name <- paste(v, colnames(mat), sep = "*")
colnames(A) <- paste(col_name, collapse = " + ")
head(A, n = 10)
vnorm <- function(x) {
as.vector(sqrt(t(x) %*% x)) # convert a matrix into a vector
}
v <- 1:5
vnorm(v)
v
u <- v / vnorm(v)
u
vnorm(u)
is_square <- function(X) {
if (!is.matrix(X)) {
stop("input must be a matrix")
}
if (ncol(X) == nrow(X)) {
TRUE
} else {
FALSE
}
}
is_square(A)
A
I <- diag(5)
I
is_square(I)
A <- matrix(1:6, ncol = 2, nrow = 3)
A
is_square(A)
is_square <- function(X) {
if (!is.matrix(X)) {
stop("input must be a matrix")
}
if (ncol(X) == nrow(X)) {
TRUE
} else {
FALSE
}
}
I <- diag(5)
I
is_square(I)
A <- matrix(1:6, ncol = 2, nrow = 3)
A
is_square(A)
is_square <- function(X) {
if (!is.matrix(X)) {
stop("input must be a matrix")
}
if (ncol(X) == nrow(X)) {
TRUE
} else {
FALSE
}
}
I <- diag(3)
I
is_square(I)
A <- matrix(1:6, ncol = 2, nrow = 3)
A
is_square(A)
I
seq_along(I)
seq_along(nrow(I))
seq_along(nrow(I))
nrow(I)
numeric(1)
diag(I)
diag(3)
mtrace <- function(X) {
if(!is_square(X)) {
stop("The matrix must be a square matrix")
}
sum(diag(X))
}
A <- matrix(1:9, ncol = 3, nrow = 3)
A
mtrace(A)
mtrace <- function(X) {
if(!is_square(X)) {
stop("The matrix must be a square matrix")
}
sum(diag(X))
}
A <- matrix(1:9, ncol = 3, nrow = 3)
A
mtrace(A)
A <- matrix(1:9, ncol = 3, nrow = 3)
B <- diag(3)
A <- matrix(1:9, ncol = 3, nrow = 3)
B <- diag(3)
A
B
A + B
C <- A + B
mtrace(C) == trace(A) + trace(B)
mtrace(C) == (trace(A) + trace(B))
mtrace(C) == mtrace(A) + mtrace(B)
mtrace(D) == 5 * mtrace(A)
A <- matrix(1:9, ncol = 3, nrow = 3)
B <- diag(3)
A
B
C <- A + B
D <- 5 * A
mtrace(C) == mtrace(A) + mtrace(B)
mtrace(D) == 5 * mtrace(A)
X <- matrix(1:6, nrow = 2, ncol = 3)
Y <- matrix(11:16, nrow = 3, ncol = 2)
X
Y
tXY <- crossprod(X, Y)
X <- matrix(1:6, nrow = 2, ncol = 3)
Y <- matrix(11:16, nrow = 3, ncol = 2)
X
Y
tXY <- crossprod(X, Y)
?crossprod()
tXY <- crossprod(X, Y)
X <- matrix(1:6, nrow = 2, ncol = 3)
Y <- matrix(11:16, nrow = 3, ncol = 2)
X
Y
X <- matrix(1:6, nrow = 2, ncol = 3)
Y <- matrix(11:16, nrow = 2, ncol = 3)
X
Y
tXY <- crossprod(X, Y)
XtY <- tcrossprod(X, Y)
tYX <- crossprod(Y, X)
YtX <- tcrossprod(Y, X)
mtrace(tXY) == mtrace(XtY)
mtrace(XtY) == mtrace(tYX)
mtrace(tYX) == mtrace(YtX)
mtrace(YtX) == mtrace(tXY)
X <- matrix(1:6, nrow = 2, ncol = 3)
Y <- matrix(11:16, nrow = 2, ncol = 3)
X
Y
tXY <- crossprod(X, Y)
XtY <- tcrossprod(X, Y)
tYX <- crossprod(Y, X)
YtX <- tcrossprod(Y, X)
mtrace(tXY) == mtrace(XtY)
mtrace(XtY) == mtrace(tYX)
mtrace(tYX) == mtrace(YtX)
mtrace(YtX) == mtrace(tXY)
M <- mtcars %>% select(mpg, disp, hp, drat, wt)
M
M <- as.matrix(M)
M
class(M)
?apply
apply(M, 2, mean)
M_mean <- apply(M, 2, mean)
colnames(M_mean) <- paste("mean", colnames(M_mean), sep = "_")
paste("mean", colnames(M_mean), sep = "_")
colnames(M_mean)
M_mean
class(M_mean)
names(M_mean)
names(M_mean) <- paste("mean", names(M_mean), sep = "_")
M_mean
?scale
Mc <- scale(M, center = TRUE, scale = FALSE)
Mc
head(Mc, n = 10)
apply(Mc, 2, mean)
apply(Mc, 2, mean)
Mc <- scale(M, center = TRUE, scale = FALSE)
head(Mc, n = 10)
Mc_mean <- apply(Mc, 2, mean)
names(Mc_mean) <- paste("mean", names(Mc_mean), sep = "_")
Mc_mean
?sweep
sweep(M, 2, apply(M, 2, mean), FUN = "-")
sweep_M <- sweep(M, 2, apply(M, 2, mean), FUN = "-")
Mc == sweep_M
head(Mc == sweep_M, n = 10)
apply(M, 2, max)
M_max <- apply(M, 2, max)
M_max <- apply(M, 2, max)
names(M_max) <- paste("max", names(M_max), sep = "_")
M_max
sweep(M, 2, M_max, FUN = "/")
head(sweep(M, 2, M_max, FUN = "/"), n = 10)
scale(M)
scale(M, center = FALSE)
apply(M, 2, min)
M_min <- apply(M, 2, min)
M_max - M_min
M_max
max_min <- M_max - M_min
M1 <- sweep(M, 2, M_min, FUN = "-")
head(M2, n = 10)
M_min <- apply(M, 2, min)
max_min <- M_max - M_min
M1 <- sweep(M, 2, M_min, FUN = "-")
M2 <- sweep(M1, 2, max_min, FUN = "/")
head(M2, n = 10)
max(M@)
max(M2)
min(M2)
M_min <- apply(M, 2, min)
max_min <- M_max - M_min
M1 <- sweep(M, 2, M_min, FUN = "-")
M2 <- sweep(M1, 2, max_min, FUN = "/")
head(M2, n = 10)
max(M2)
min(M2)
(t(Mc) %*% Mc) / nrow(Mc)
cov(M)
(t(M) %*% M) / nrow(M)
(t(Mc) %*% Mc) / (nrow(Mc) - 1)
crossprod(Mc) / (nrow(Mc) - 1)
crossprod(Mc) / (nrow(Mc) - 1)
cov(M)
crossprod(Mc) / (nrow(Mc) - 1)
cov(M)
cov_M <- crossprod(Mc) / (nrow(Mc) - 1)
cov_M == cov(M)
cov_M <- crossprod(Mc) / (nrow(Mc) - 1)
cov_M == cov(M)
cov_M <- crossprod(Mc) / (nrow(Mc) - 1)
cov_M == cov(M)
crossprod(Mc) / (nrow(Mc) - 1)
cov(M)
